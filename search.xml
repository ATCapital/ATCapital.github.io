<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用python发送QQ邮件]]></title>
    <url>%2F2017%2F06%2F06%2Fpython-email%2F</url>
    <content type="text"><![CDATA[只掌握皮毛的自动发邮件提醒功能。 12345678910111213141516171819202122# -*- coding: utf-8 -*-import smtplibfrom email.mime.text import MIMEText_user = "自己的QQ邮箱"_pwd = "授权码"_to = "他人的QQ邮箱"msg = MIMEText("测试")msg["Subject"] = "这是测试邮件"msg["From"] = _usermsg["To"] = _totry: s = smtplib.SMTP_SSL("smtp.qq.com", 465) s.login(_user, _pwd) s.sendmail(_user, _to, msg.as_string()) s.quit() print "Success!"except smtplib.SMTPException, e: print "Falied,%s" % e]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqlite3笔记]]></title>
    <url>%2F2017%2F04%2F28%2Fsqlite3%2F</url>
    <content type="text"><![CDATA[sqlite3学习笔记 基础运用基本功能 功能 代码 查询当前数据库 .databases 查询当前表 .tables 查询表的详细信息 .schema .mode column 设置输出列的宽度 .width 10, 20, 10 创建数据库 cmd下$sqlite3 DatabaseName.db 附加数据库 ATTACH DATABASE &#39;DatabaseName&#39; As &#39;Alias-Name&#39;; 分离数据库 DETACH DATABASE &#39;Alias-Name&#39;; 创建表 CREATE TABLE COMPANY(ID INT PRIMARY KEY NOT NULL, NAME TEXT NOT NULL); 删除表 DROP TABLE TABLE_NAME; 添加数据 INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) VALUES (1, &#39;Paul&#39;, 32, &#39;California&#39;, 20000.00 ); 添加另一个表的数据 INSERT INTO T_1 [(column1, column2)] SELECT column1, column2 FROM T_2 [WHERE condition]; 选择数据 SELECT column1, column2 (or *) FROM table_name; 逻辑运算 运算符 描述 AND/OR/BETWEEN - EXISTS DELETE FROM employees WHERE EXISTS (SELECT * FROM departments WHERE employees.department_id = departments.department_id AND departments.department_name = &#39;IT&#39;); IN/NOT IN IN ( 25, 27 ); # 25或者27 LIKE 相似值进行比较。SELECT * FROM COMPANY WHERE NAME LIKE &#39;Ki%&#39;; GLOB 和LIKE相似，不同之处在于，它是大小写敏感的。SELECT * FROM COMPANY WHERE NAME GLOB &#39;Ki*&#39;; IS NULL - 丨丨 连接两个不同的字符串，得到一个新的字符串。 UNIQUE UNIQUE 运算符搜索指定表中的每一行，确保唯一性（无重复）。 表达式123SELECT * FROM COMPANY WHERE SALARY = 10000; -- 布尔表达式SELECT COUNT(*) AS "RECORDS" FROM COMPANY; -- 数值表达式SELECT CURRENT_TIMESTAMP; -- 日期表达式 Where体会下面两者的区别。1234SELECT AGE FROM COMPANYWHERE EXISTS (SELECT AGE FROM COMPANY WHERE SALARY &gt; 65000);SELECT * FROM COMPANYWHERE AGE &gt; (SELECT AGE FROM COMPANY WHERE SALARY &gt; 65000); Update12UPDATE COMPANY SET ADDRESS = 'Texas' WHERE ID = 6;UPDATE COMPANY SET ADDRESS = 'Texas', SALARY = 20000.00; Delete12DELETE FROM COMPANY WHERE ID = 7;DELETE FROM COMPANY; -- delete all Like百分号（%）代表零个、一个或多个数字或字符。下划线（_）代表一个单一的数字或字符。这些符号可以被组合使用。1WHERE SALARY LIKE '_2%3' -- 查找第二位为 2，且以 3 结尾的任意值 Glob星号（*）代表零个、一个或多个数字或字符。问号（?）代表一个单一的数字或字符。这些符号可以被组合使用。1WHERE SALARY GLOB '?2*3' -- 查找第二位为 2，且以 3 结尾的任意值 Limit限制由 SELECT 语句返回的数据数量。1SELECT * FROM COMPANY LIMIT 3 OFFSET 2; -- 从第三位开始提取 3 个记录 Order By12SELECT * FROM COMPANY ORDER BY SALARY ASC; -- 升序SELECT * FROM COMPANY ORDER BY NAME DESC; -- 降序 Group By在 SELECT 语句中，GROUP BY 子句放在 WHERE 子句之后，放在 ORDER BY 子句之前。12SELECT NAME, SUM(SALARY)FROM COMPANY GROUP BY NAME ORDER BY NAME DESC; HavingGroup by的条件语句，必须连用。1SELECT * FROM COMPANY GROUP BY name HAVING count(name) &gt; 2; Distinct与 SELECT 语句一起使用，用来消除所有重复的记录。1SELECT DISTINCT name FROM COMPANY;]]></content>
      <tags>
        <tag>sqlite</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python OS]]></title>
    <url>%2F2017%2F04%2F15%2Fpython-OS%2F</url>
    <content type="text"><![CDATA[python 打开文件的不同模式 模式 描述 r 只读，指针在文档起始位置 rb 二进制只读，指针在文档起始位置，推荐 r+ 读写，指针在文档起始位置 rb+ 二进制读写打开，指针在文档起始位置 w 只写，当文档存在时直接覆盖，当文档不存在时创建 wb 二进制只写，当文档存在时直接覆盖，当文档不存在时创建 w+ 读写，当文档存在时直接覆盖，当文档不存在时创建 wb+ 二进制读写，当文档存在时直接覆盖，当文档不存在时创建 a 增补模式，指针在文档结束位置，当文档不存在时创建 ab 二进制增补模式，指针在文档结束位置，当文档不存在时创建 a+ 增补只读模式，指针在文档结束位置，当文档不存在时创建 ab+ 二进制增补只读模式，指针在文档结束位置，当文档不存在时创建]]></content>
  </entry>
  <entry>
    <title><![CDATA[The Python Standard Library]]></title>
    <url>%2F2017%2F02%2F15%2Fpython-lib%2F</url>
    <content type="text"><![CDATA[Python基本库查阅参考资料 1.内建函数|abs(x)|返回绝对值||chr(i)|||zip([iterable, …])|类似map(None, iterable, iterable)，返回包含tuple的list|map(function, iterable, …)|将funtion运用到iterable中，如果有多个参数就多加个iterable 2. 内置类型2.8 Dict|keys()|返回key的list|items()|返回(key, value)的list 3. String模块4. Data模块5. 数学模块5.6 random生成假随机数，很多方法numpy也有。 |random.seed(a=None)|类似以撒的seed，产生随机数顺序一样||random.uniform(a, b)|返回随机数 [a,b]，ab位置可换|random.randint(a, b)|返回随机整数a &lt;= N &lt;= b||random.choice(seq)|随机返回seq的一个值，空则IndexError|random.random()|返回 [0,1)|random.gauss(mu, sigma)|高斯分布又叫正态分布，稍比normalvariate快|random.normalvariate(mu, sigma)|正态分布同上 6. 文件目录访问7. 数据存储7.1 pickle此模块是Python内置用于数据存储的库，把变量从内存存入到文件的过程。Pickle有通过C优化后的兄弟库叫cPickle，官方说法快1000倍，所以使用时这样引用: 1234try: import cPickle as pickleexcept ImportError: import pickle 录入数据 |pickle.dump(obj, file[, protocol])|导出到文件 |pickle.dumps(obj[, protocol])|导出为字符串 |Protocol|描述|0|original ASCII 默认值|1|old binary format|2|more efficient|negative|HIGHEST_PROTOCOL will be used 读取数据 |pickle.load(file)|从文件读取数据 |pickle.loads(string)|从字符串读取数据 Pickle 每次序列化生成的字符串有独立头尾，按照先进先出（FIFO）的顺序保存，可以建个字典存储读取。pickle.load() 只会读取一个完整的结果，所以你只需要在 load 一次之后再 load 一次，就能读到第二次序列化的数据。如果不知道文件里有多少 pickle 对象，可以在 while 循环中反复 load 文件对象，直到抛出异常为止。]]></content>
  </entry>
  <entry>
    <title><![CDATA[从雅虎财经获取数据说起]]></title>
    <url>%2F2017%2F02%2F09%2Fyahoo-finance%2F</url>
    <content type="text"><![CDATA[一些非常简单的试验。 这篇主要梳理下使用pandas-datareader来获取财经数据进行简单分析的过程。pandas-datareader之前是封装在pandas里，但之后被移除，所以需要单独安装下$ pip install pandas-datareader。行情数据在data类下，调用方法import pandas_datareader.data as web。 Doc说明文档 首先使用DataReader函数获取数据。 1df = web.DataReader('600030.SS', 'yahoo', start, end) 计算对数收益率: 12df['return'] = np.log(df['Close'] / df['Close'].shift(1))df[['Close', 'return']].plot(subplots=True) 可以观察波动率和收盘价的关系。 计算移动平均值：使用pd.rolling函数创建一行新列，再绘图观察即可。具体的代码是： 123df['21d'] = df['Close'].rolling(windows=21).mean()df[['Close', '21d']].plot()plt.show() 实际上到这里就画出了收盘价线和移动平均线，简单的居于均线趋势分析的方法就可以在这里开始检验了，是不是很简单呢。]]></content>
      <tags>
        <tag>pandas</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib库使用简介]]></title>
    <url>%2F2017%2F02%2F06%2Fmatplotlib%2F</url>
    <content type="text"><![CDATA[matplotlib使用笔记。 绘图函数主要在子库matplotlib.pyplot中，下面介绍的都是pyplot的函数。 import matplotlib.pyplot as plt pyplot类figure函数|创建图层|matplotlib.pyplot.figure(num=None, figsize=None, dpi=None, facecolor=None, edgecolor=None, frameon=True, FigureClass=&lt;class &#39;matplotlib.figure.Figure&#39;&gt;, **kwargs)|plt.figure(figsiz=(7,4)) plot函数|绘图，线条参数，颜色参数|matplotlib.pyplot.plot(*args, **kwargs)|plot(x, y, &#39;bo&#39;) # plot x and y using blue circle markers |参数|例子|linewidth or lw|lw=1.5 grid函数|显隐网格|matplotlib.pyplot.grid(b=None, which=&#39;major&#39;, axis=&#39;both&#39;, **kwargs)|ax.grid(True)ax.grid(color=&#39;r&#39;, linestyle=&#39;-&#39;, linewidth=2) axis函数，xlim函数，ylim函数|坐标轴设置|matplotlib.pyplot.axis(*v, **kwargs)|axis(v) # 设置坐标极值 v = [xmin, xmax, ymin, ymax]axis(&#39;off&#39;) # 关闭axis(&#39;equal&#39;) # 等刻度axis(&#39;tight&#39;) # 边界和数据重叠axis(&#39;image&#39;) # 所有数据可见 |设置或者获取边界|matplotlib.pyplot.xlim(*args, **kwargs)|xmin, xmax = xlim() # return the current xlimxlim( (xmin, xmax) ) # set the xlim to xmin, xmaxxlim( xmin, xmax ) # set the xlim to xmin, xmaxxlim(xmax=3) # adjust the max leaving min unchanged xlabel函数，ylabel函数，title函数|设置标签|matplotlib.pyplot.xlabel(s, *args, **kwargs)matplotlib.pyplot.ylabel(s, *args, **kwargs)matplotlib.pyplot.title(s, *args, **kwargs)|plt.title(&#39;title&#39;) legend函数|设置图例格式位置等等，具体参数|matplotlib.pyplot.legend(*args, **kwargs)|plt.legend(loc=0) subplots函数和subplot函数|创建子图，如果有多图使用此函数|matplotlib.pyplot.subplots(nrows=1, ncols=1, sharex=False, sharey=False, squeeze=True, subplot_kw=None, gridspec_kw=None, **fig_kw)|fig, (ax1, ax2) = plt.subplots(1, 2, sharey=True) # 这里的1，2代表图表的排列ax1.plot(x, y) # 直接用轴类的方法就可以了ax1.set_title(&#39;Sharing Y axis&#39;)ax2.scatter(x, y) |也可以使用subplot函数画子图，不过没有subplots直观。subplot函数的作用是规划子图的位置。|subplot(nrows, ncols, plot_number) scatter函数|根据x，y画散点图|matplotlib.pyplot.scatter(x, y, s=None, c=None, marker=None, cmap=None, norm=None, vmin=None, vmax=None, alpha=None, linewidths=None, verts=None, edgecolors=None, **kwargs)| hist函数|直方图|matplotlib.pyplot.hist(x, bins=None, range=None, normed=False, weights=None, cumulative=False, bottom=None, histtype=&#39;bar&#39;, align=&#39;mid&#39;, orientation=&#39;vertical&#39;, rwidth=None, log=False, color=None, label=None, stacked=False, hold=None, data=None, **kwargs)| Axes类常用的方法（散点图，直方图等）在此类中也通用。 参考资料 twinx函数|设置y的次坐标轴|Axes.twinx()|ax2 = ax1.twinx() set_title函数|设置坐标轴标题|Axes.set_title(label, fontdict=None, loc=&#39;center&#39;, **kwargs)|ax1.set_title(&#39;title&#39;)]]></content>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NumPy库使用简介]]></title>
    <url>%2F2017%2F02%2F05%2Fnumpy%2F</url>
    <content type="text"><![CDATA[NumPy使用笔记。 Quick Sheet1234567891011121314151617import numpy as nparr = np.array([]) # 创立numpy数组arr.T # 转置arr[ : :-1] # reversearr.shape # 显示数组结构arr.reshape # 重构数组arr.size # shape结果的乘积arr.dtype # arr.dtype.namenp.arange( 0, 2, 0.3 ) # array([ 0. , 0.3, 0.6, 0.9, 1.2, 1.5, 1.8])np.linspace( 0, 2, 9 ) # array([ 0. , 0.25, 0.5 ... 1.75, 2. ])np.sum(arr) # 求和np.mean(arr) # 均数np.std(arr) # 标准差np.sqrt(arr) # 平方根np.floor(arr) # 向下取整np.dot(arr1, arr2) # 点积np.vectorize() # 向量化 vfunc = np.vectorize(myfunc) 注意 np.sin 不要与 math.sin 覆盖。12import mathmath.sin() ReferenceArrary Objectndarray创立的数组里属于此类，此类可以进行向量化运算，可以使用 x[row][column] 查值。常用方法：123np.sum(axis, dtype) # 按照axis, dtype求和np.cumsum(axis, dtype) # 按照axis, dtype累计求和np.std(axis, dtype) # 按照axis, dtype求标准差 dtypeData type12345x = np.float32(1.0)d = np.dtype(int)# 结构数组dt = np.dtype([('Name', 'S10'), ('Age', 'i4')])s = np.array([('Smith', 45), ('Jones', 53)], dtype = dt) RoutinesArrary Creation12345678910111213141516# numpy.arraynumpy.array(object, dtype=None, copy=True, order='K', subok=False, ndmin=0)&gt;&gt;&gt; np.array([1, 2, 3], dtype=complex)&gt;&gt;&gt; array([ 1.+0.j, 2.+0.j, 3.+0.j])# numpy.zeros# 创建一个用0填充的数组numpy.zeros(shape, dtype=float, order='C')&gt;&gt;&gt; np.zeros((5,), dtype=np.int)array([0, 0, 0, 0, 0])# numpy.empty# 生成用随机数填充的数组，速度较快，不推荐使用numpy.empty(shape, dtype=float, order='C')&gt;&gt;&gt; np.empty([2, 2], dtype=int)array([[-1073741821, -1067949133], [496041986, 19249760]]) # random Random123numpy.random.standard_normal(size=None) # 模拟标准正态分布的样本s = np.random.standard_normal((4,3))numpy.random.randint(low, high=None, size=None, dtype='l') # 返回随机整数, int Mathematical functions123np.log([1, np.e, np.e**2, 0])# numpy.log，numpy.log10，numpy.log2，numpy.log1p# log1p == log(1+x) Logic functions12345# allclose# 如果两个数组在一定误差范围内则返回True# absolute(a - b) &lt;= (atol + rtol * absolute(b))numpy.allclose(a, b, rtol=1e-05, atol=1e-08, equal_nan=False)np.allclose([1.0, np.nan], [1.0, np.nan], equal_nan=True) # True Ref:[1]: NumPy manual contents]]></content>
      <tags>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[吉他谱]]></title>
    <url>%2F2017%2F02%2F04%2Fguitar-tab%2F</url>
    <content type="text"><![CDATA[吉他谱记录。 小拳拳捶你胸口 capo 5 C - G - F - G - C (｡•ˇ‸ˇ•｡)哼！都怪你 (`ȏ´) 也不哄哄人家(〃′o`) C - G - F - G - C (〃′o`)人家超想哭的，捶你胸口，老公！大坏蛋！！！(￣^￣)ゞ C - G - F - G - C (￣^￣)ゞ咩QAQ 捶你胸口 你好讨厌！(=ﾟωﾟ) C - G (｡•︿•̀｡)大坏蛋(｡•ˇ‸ˇ•｡)，打死你(つд⊂) F - G - C (｡•︿•̀｡)大坏蛋(｡•ˇ‸ˇ•｡)，打死你(つд⊂) F - C - G - Am - F - G - C (=ﾟωﾟ)ﾉ要抱抱嘤嘤嘤哼，人家拿小拳拳捶你胸口！！！(｡•︿•̀｡) F - C - G - Am - F - G - C (=ﾟωﾟ)ﾉ要抱抱嘤嘤嘤哼，人家拿小拳拳捶你胸口！！！(｡•︿•̀｡) 【秋风MusiX】教你如何用吉他把【小拳拳捶你胸口】编成歌]]></content>
      <tags>
        <tag>guitar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[量化常用策略]]></title>
    <url>%2F2017%2F02%2F02%2Fstrategy%2F</url>
    <content type="text"><![CDATA[策略-&gt;系统-&gt;执行-&gt;反馈 交易的本质低买高卖，寻找自我。 交易的理念均值回归&amp;趋势延伸。mean-reversion&amp;momentum一个完美的策略应该是结合上诉这两点的，简单的打个比方，在上涨趋势的回调处做多。 策略简介注：每个人适合的策略都不一样，也就是风险偏好不一样，如果选择不当，就会成为别人的alpha哦。 资本增值 长周期 整体经济的不断发展，周期性-&gt;长周期的beta策略长周期的beta策略莫过于指数定投，个人还是非常喜欢这类策略的，简单粗暴，似乎有很多人认为这类策略的收益率不是很高，其实不是这样的。定投的关键的降低平均持仓成本，如果加上一些模式识别会产生非常好的效果。对于一般以理财为目的的人来说，定投指数ETF是非常好的选择，性价比非常高。 价值投资，低估值-&gt;多因子选股 短周期 技术面的撑压线-&gt;模式识别，趋势反转 突破战法 人性的弱点 追涨杀跌（贪婪恐惧） 趋势策略最有名的趋势策略莫过海龟策略，一个长期期望为正的策略，缺点就是回撤太大。如果周期选的过小则无法过滤无效波动，算上交易手续费会产生极大的亏损，但周期过大则会产生极大的滑点，回撤也会难以接受，而中间的调参又会陷入一个过度优化的悖论，时至今日感觉似乎有点鸡肋。不过目前在国内市场中很多CTA的策略还是以趋势为主，周期较短，还是有待考察。个人认为股票市场中长周期的趋势策略跟指数定投收益接近，而指数定投所花费的其他成本更低。 逐利性 便宜货 均值回归（择时策略） 套利 统计套利 做市策略 信息不对称 内幕交易 操纵市场]]></content>
      <tags>
        <tag>策略</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pandas库使用简介]]></title>
    <url>%2F2017%2F01%2F25%2Fpandas%2F</url>
    <content type="text"><![CDATA[Pandas学习笔记。 1import pandas as pd IO ToolsFlat File123456789# CSVdf = pd.read_csv('foo.csv', index_col=0, parse_dates=True)# or index_col='date' 将data列作为index，并且解析日期pd.read_csv('tmp.csv', dayfirst=True, parse_dates=[0]) # 以DD/MM解析首列信息df = pd.read_csv('tmp.csv', sep='|', thousands=',')# Patient1|123,000|x &gt;&gt;&gt; 0 Patient1 123000 xdata = 'skip this skip it\na,b,c\n1,2,3\n4,5,6\n7,8,9'pd.read_csv(StringIO(data), header=1)# header是标题行的起始位置，None就是没有，0就是第一行 Time SeriesTimestamps12345678910111213141516171819202122from datetime import datetimepd.Timestamp(datetime(2012, 5, 1)) # Timestamp('2012-05-01 00:00:00')pd.Timestamp('2012-05-01')pd.Timestamp(2012, 5, 1)# Converting to Timestampspd.to_datetime(pd.Series(['Jul 31, 2009', '2010-01-10', None]))pd.to_datetime(['04-01-2012 10:00'], dayfirst=True)pd.to_datetime(['2009/07/31', 'asd'], errors='raise') # ValueError: Unknown string formatpd.to_datetime(['2009/07/31', 'asd'], errors='ignore') # return original inputpd.to_datetime(['2009/07/31', 'asd'], errors='coerce') # Return NaT# Epoch Timestampspd.to_datetime([1, 3.14], unit='s') # 以s计算&gt;&gt;&gt;DatetimeIndex(['1970-01-01 00:00:01', '1970-01-01 00:00:03.140000'], dtype='datetime64[ns]', freq=None)start = datetime(2011, 1, 1)end = datetime(2012, 1, 1)rng = pd.date_range(start, end)rng = pd.bdate_range(start, end) # business daypd.date_range(start, end, freq='BM')pd.bdate_range(end=end, periods=20) DatetimeIndex123456789rng = pd.date_range(start, end, freq='BM')ts = pd.Series(np.random.randn(len(rng)), index=rng)ts['10/31/2011':'12/31/2011'] # 取出之间的数据ts['2011'] # 取出2011年全年数据dft = pd.DataFrame(randn(100000,1), columns=['A'], index=pd.date_range('20130101',periods=100000,freq='T'))dft[datetime(2013, 1, 1, 10, 12, 0):datetime(2013, 2, 28, 10, 12, 0)]# Truncating &amp; Fancy Indexingts.truncate(before='10/31/2011', after='12/31/2011') DateOffset12345678910111213141516171819202122232425from pandas.tseries.offsets import *d = datetime(2008, 8, 18, 9, 0)d + DateOffset(months=4, days=5)&gt;&gt;&gt; Timestamp('2008-12-23 09:00:00')d - 5 * BDay()d + BMonthEnd() # 最近的business month endoffset = BMonthEnd()offset.rollforward(d) # 往后最近的BMonthEndoffset.rollback(d) # 往前最近的BMonthEndday = Day(normalize=True)day.apply(pd.Timestamp('2014-01-01 09:00'))&gt;&gt;&gt; Timestamp('2014-01-02 00:00:00')hour = Hour(normalize=True)hour.apply(pd.Timestamp('2014-01-01 22:00'))&gt;&gt;&gt; Timestamp('2014-01-01 00:00:00')d + YearEnd(month=6)&gt;&gt;&gt; Timestamp('2009-06-30 09:00:00')# Using offsets with Series / DatetimeIndexrng = pd.date_range('2012-01-01', '2012-01-03')s = pd.Series(rng)s + DateOffset(months=2)# Converting to Python datetimesd.to_pydatetime() Series123456789101112# Creations = pd.Series(data, index=index) # Series是一维数组pd.Series(np.random.randn(5), index=['a', 'b', 'c', 'd', 'e']) # From ndarraypd.Series(d = &#123;'a' : 0., 'b' : 1., 'c' : 2.&#125;) # From dictpd.Series(5., index=['a', 'b', 'c', 'd', 'e']) # From scalar value# usage，常规函数见DataFrames[s &gt; s.median()]s[[4, 3, 1]]np.exp(s)s['a']s.get('f', np.nan) # 取值 DataFrame1234567891011121314# Creation# From dict of Series or dictsd = &#123;'one' : pd.Series([1., 2., 3.], index=['a', 'b', 'c']), 'two' : pd.Series([1., 2., 3., 4.])&#125;pd.DataFrame(d, index=['d', 'b', 'a'], columns=['two', 'three'])# From dict of ndarrays / listsd = &#123;'one' : [1., 2., 3., 4.], 'two' : [4., 3., 2., 1.]&#125;pd.DataFrame(d, index=['a', 'b', 'c', 'd'])# From structured or record arraydata = np.zeros((2,), dtype=[('A', 'i4'),('B', 'f4'),('C', 'a10')])data[:] = [(1,2.,'Hello'), (2,3.,"World")]pd.DataFrame(data)# From a list of dictsdata2 = [&#123;'a': 1, 'b': 2&#125;, &#123;'a': 5, 'b': 10, 'c': 20&#125;]pd.DataFrame(data2) Attributes12345df.indexdf.valuesdf.columnsdf.ix[['a', 'b']] or df.ix[df.index[1:3]]df.size Indexing, Selection12345678# Indexdf.loc['b']df.iloc[2]df.drop() # Delete given row or column. Pass axis=1 for columns.df1 = df1.reindex_like(df1,df2) # Reindex df1 with index of df2.df.reindex(new_index)df.head(n)df.tail(n) Function application12345678910# apply 函数附加df.apply(numpy.sum, axis=1) # equiv to df.sum(1)# groupbydata.groupby(['col1', 'col2'])['col3'].mean()# rollingdf.rolling(2, win_type='blackman').sum()df.rolling(20).mean() # 移动平均线current_price &lt; stock.rolling(window=50).min()df.apply(numpy.sum, axis=0) # equiv to df.sum(0)df.applymap() # df = df.applymap(lambda x: '%.2f' % x) 对每个元素使用 Computations12345678sum(axis) # df.sum(axis=0)cumsum(axis) # 累计求和mean(axis)std(axis)describe()max(axis)corr() # method : &#123;‘pearson’, ‘kendall’, ‘spearman’&#125;df.count() # Returns Series of row counts for every column. Combining1234df.append(df2, ignore_index=True)caller.join(other.set_index('key'), on='key') # 主要用于index合并。how默认left向左合并 outer并集A.merge(B, left_on='lkey', right_on='rkey', how='outer') # 根据其中一列的键值合并concat() # Series的合并 Time series-related1df/df.shift(1) # 数据向后移动n个index Missing data handling12fillna(method='ffill') # front fill 使用前面的数据填充, 避免前视问题df.dropna() # Drops rows where any data is missing. Reshaping, sorting, transposing123456df.sort_indexdf.sort_values# pivot Reshape data (produce a “pivot” table) based on column values.df.pivot(index='foo', columns='bar', values='baz')# stackdf.stack/unstack Plotting1data.plot() I/O1234df.to_csv(‘foo.csv’)read_csv(‘foo.csv’)to_excel(‘foo.xlsx’, sheet_name)read_excel(‘foo.xlsx’,’sheet1’, index_col = None, na_values = [‘NA’]) GroupByRef:[1]: API Reference]]></content>
      <tags>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[量化系统的构建]]></title>
    <url>%2F2017%2F01%2F22%2Fsystem%2F</url>
    <content type="text"><![CDATA[整理量化策略搭建的主流策略，从数据中发现价值。 程序主体的设计：其一，自上而下的构建，通过交易理念推导出交易系统，并将其程序化。比如索罗斯的交易系统，便是由他的反射理论，推导构建出的交易程序。其实主要包括两大类：宏观层面和人性层面。其二，大数据观察，统计模型判断，建模，判断规则的漏洞或者是feature(董可人：冰山策略)。主要是套利类的策略，统计套利，高频做市等。其三，自下而上的构建，通过反复的观察，模式识别，将其程序化。跟第二种比较类似，但是稍有区别，人性的成分更多些，例如热点追击，动量策略源于此。 交易程序的初步检验：交易系统的检验，必须充分考虑手续费和滑点的影响。通常认为，在这一步，系统的胜率应该在50%以上，最大回撤时间不超过90个周期（因不同级别的交易系统不能按统一时间计算），连续亏损次数不超过5次，那么这个系统基本具备持续盈利的能力。 交易系统的优化：谨防overfit，主要是风控部分。 交易系统的外推检验：通过了优化的系统，已经初步成熟，外推检验就像生产线中的质检一样，一个产品能否上市，这是最重要的一个环节，对前期的结论具有一票否决权。外推检验分两种：一种是时间外推，即用更多的数据进行回测，观察交易系统是否稳定。二种是品种外推，如题主的螺纹程序，拿去橡胶，铜，豆粕，股指这些活跃品种上进行回测，甚至在外汇，国外商品，国外股市上进行检验。一套具备实盘盈利前景的系统，必须适用于市场上绝大部分品种的交易。如果不能经过外推检验，那么这个系统很可能只是一个偶然，或者已经过度优化了。 交易系统的实盘使用和维护：很少有系统是能经过第四条检验的，如果走到这一步，恭喜了，你可以相对安心的用它来赚钱了。当然也不是睡睡觉数数钱那么简单，电脑有时候也是会出问题的，这个问题暂且不论，一个非常严重的现象是，行情波动的特征是会变的。其变化表现在：其一，波动特性改变了。举例来说：2005年之前，只要有个最简单最简单的均线系统（上五日线做多，下五日线反手做空），就可以发大财了。但是2005年以后，这样简单的系统获利已经不稳定，而09年以后，基本就不可能再用来获利了。又如前几年，做股指高频交易的人都发财了，我听到最高的一年有30倍，但是现在，高频交易都已经开始自相残杀了。为什么？因为市场上精明的交易者越来越多了，当你的对手还在用肉搏的时候，只要有一把手枪就可以称王，但是现在，大家都已经开上飞机坦克了，战场结构必然变化。其二，交易环境变化。比如今年，期货夜盘的大量推出，导致不同时间段的交易分布不再均匀，很多交易系统便不能适应了。前两年期货很多小合约改成了大合约，也导致了很多微观波动结构的改变。所以交易系统必须时时进行维护和修补，甚至必要时直接宣布它死亡。 从这一点上看，又可以发现，第一步设计交易系统的两种方式的优劣。自下而上开发的系统，永远只是根据开发时期的数据作为样本，日后修改起来将非常频繁，也非常困难，而自上而下开发的系统，它是接近于本质的，而市场波动的本质特征，几百年来都未曾改变，只不过表现方式变了而已。 如何看待交易系统失效董可人：理论上，要用科学方法进行分析。市场环境有没有变化？比如波动性有没有异常，延迟水平是否仍保持领先，甚至交易所的规则或策略有无变化，这些都有可能造成影响，需要仔细分析数据才能得出结论。实际上很多时候，仔细分析过就会发现仍有巨大的改进空间。简单说就是一个大胆假设，小心求证，科学化系统化的分析过程，这也是为什么这一行会偏爱PhD，因为和学术研究还挺有相似之处的。现实中，因为决策层和执行层的分离，这个问题的答案基本上是“看心情”。高层或者客户可能根本没有兴趣看你们的细节分析，才不会管你什么科学不科学。如果你在有限的时间内没能拿出一个有效的方案，即便理论上还有很多可能性，人家就会想 “F##k it. We are losing money so we stop”。不相信我说的？请看 @腾天老师名言：“DON’T BE A DICK FOR A PIP”。 小须弥咩：任何一个交易系统，一定要有客观、明确的界定其失效（死亡）的方法。没有任何一个系统是可以一劳永逸的，即便是自上而下的系统，也是会有失效的时候，只不过使用周期比较长，所以必须要有界定其死亡的标准。比如上图的白银系统，最近半年我都没有修改，中间经历了2个多月的调整，我当时判断它死亡的标准是，回撤掉前期利润总和的1/10或者超过3个月，判断为留院观察，再等2月资金曲线不能创新高直接宣布死亡。]]></content>
      <tags>
        <tag>量化系统</tag>
        <tag>策略</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git语法备忘录]]></title>
    <url>%2F2017%2F01%2F20%2Fgit-command%2F</url>
    <content type="text"><![CDATA[主要记录Git的安装配置和基本语法。 安装配置GitGit for Windows所有操作在GitBash下进行。注册Github的账号，然后设置Git的用户名和邮箱： 12git config --global user.name &quot;username&quot;git config --global user.email &quot;your email&quot; 配置SSH 查看是否已有ssh秘钥：cd ~/.ssh，如果有则删除。 生成秘钥ssh-keygen -t rsa -C “email”，采取RSA加密，如果不设置密码则按三次回车即可，秘钥可通过cd ~/.ssh查看。Git中~表示的是User\Username这个文件夹。 在Github上添加SSH，Setting/SSH and GPG keys，复制rsa.pub的内容上去即可。测试代码ssh -T git@github.com，如果显示You’ve successfully authenticated, but GitHub does not provide shell access就说明成功了。 Push时使用SSH认证：在你下载的项目文件夹中有隐藏的.git目录，打开config，修改url = https://...为SSH的地址，地址显示在你的github项目中Clone or download里，切换为Use SSH就可以看到了。 Mac OS X 中显示隐藏文件的命令是defaults write com.apple.finder AppleShowAllFiles -bool true取消显示则改为false即可，重启Finder。CMD+Option+ESC调出。 上传文件 先cd到你需要clone的位置，执行git clone命令。 cd 到项目文件夹。 git add .添加所有文件 git commit -m &quot;revise info&quot;提交修改信息 git push origin提交远程仓库，如果完成了配置中的第四步就不需要输入密码了。Enjoy。]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown语法]]></title>
    <url>%2F2017%2F01%2F18%2Fhow-to-use-markdown%2F</url>
    <content type="text"><![CDATA[MarkDown语法笔记。如果你想要依赖 Markdown 来插入 &lt;br /&gt; 标签的话，在插入处先按入两个以上的空格然后回车。 编辑器Sublime + 一款配色主题即可。主题文件放在 Sublime/Preferences/Browse Packages或者ATOM + 自带的preview（control + shift + M）。 标题1234# 这是 H1# 这是 H1 ### 这是 H2 ##### 这是 H3 ##### 引用1234&gt; 1. 这是第一行列表项。&gt; 2. 这是第二行列表项。&gt; &gt; 给出一些例子代码：&gt; return shell_exec("echo $input | $markdown_script"); 列表123* Red+ Green- Blue 要让列表看起来更漂亮，你可以把内容用固定的缩进整理好 123* Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. 有些情况下项目列表很可能会不小心产生 11986. What a great season. 要避免这样的状况，你可以在句点前面加上反斜杠。 11986\. What a great season. 表格冒号代表左对齐。123| Header One | Header Two || :------------- | :------------- || Item One | Item Two | 代码只要简单地缩进 4 个空格或是 1 个制表符就可以。如果要标记一小段行内代码，你可以用反引号把它包起来（`），例如： 1Use the `printf()` function. 大段代码在前后插入```，例如：123```pythonsome python code``` 分隔线12345* * *********- - ---------------------------------------- 链接行内式12This is [an example](http://example.com/ "Optional Title") inline link.[This link](http://example.net/) has no title attribute. 如果你是要链接到同样主机的资源，你可以使用相对路径： 1See my [About](/about/) page for details. 参考式1This is [an example][id] reference-style link. id 不区分大小写 接着，在文件的任意处，你可以把这个标记的链接内容定义出来： 123[id]: http://example.com/ "Optional Title Here"[id]: http://example.com/ "Optional Title Here" 隐式链接标记可以省略id 12[Google][][Google]: http://google.com/ 也可以采用参考文献式 12345I get 10 times more traffic from [Google] [1] than from[Yahoo] [2] or [MSN] [3].[1]: http://google.com/ "Google"[2]: http://search.yahoo.com/ "Yahoo Search"[3]: http://search.msn.com/ "MSN Search" &lt;http://example.com/&gt; 尖括号包起来会自动把它转成链接。 强调Markdown 使用星号（）作为标记强调字词的符号，被 包围的字词会被转成用 &lt;em&gt; 标签包围，用两个 * 包起来的话，则会被转成 &lt;strong&gt;，例如： 12*single asterisks* # &lt;/em&gt; 斜体**double asterisks** # &lt;/strong&gt; 加粗 如果要在文字前后直接插入普通的星号或底线，你可以用反斜线： 1\*this text is surrounded by literal asterisks\* 删除线，使用~~ 1~~需删除的内容~~ 图片行内式12![Alt text](/path/to/img.jpg)![Alt text](/path/to/img.jpg "Optional title") 参考式12![Alt text][id][id]: url/to/image "Optional title attribute" 到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的&lt;img&gt;标签。 参考资料]]></content>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Useful links]]></title>
    <url>%2F2017%2F01%2F17%2Fuseful-links%2F</url>
    <content type="text"><![CDATA[Git代码 爬虫相关 爬虫相关 漫画]]></content>
  </entry>
  <entry>
    <title><![CDATA[从零博客之路]]></title>
    <url>%2F2017%2F01%2F16%2Fblog-set-up%2F</url>
    <content type="text"><![CDATA[从零教你搭博客。Github Pages基于静态页面，目前有两大主流框架，分别是Hexo和Jekyll。两个框架我都用过一段时间，最终我还是决定Hexo，无他，唯主题好看。两种框架都是用markdown语法，下面简单介绍下两种不同框架的搭建。 Jekyll框架环境搭建 安装RubyJekyll是使用ruby语言进行开发的，所以我们第一步需要安装ruby以及ruby相关的开发工具。安装的时候在Add Ruby executables to your PATH打勾。接下来安装相应版本的Development Kit。Development Kit的安装方法：$ cd to it $ ruby dk.rb init $ ruby dk.rb 如果不成功:$ ruby dk.rb -f 安装Jekyll $ gem install jekyll $ jekyll new blog $ cd blog $ jekyll serve 打开浏览器输入网址http://127.0.0.1:4000/就可以看原生的Jekyll博客了！PS: Mac OS X出现权限问题在命令前加上sudo。 主题安装以安装Jacman主题为例： $ ruby --version # 确保已安装Ruby 2.1.0 或更高版本 $ gem install bundler # 安装Bundler $ git clone https://github.com/Simpleyyt/jekyll-jacman.git # 下载 Jacman 主题 $ cd jekyll-jacman $ bundle install # 安装依赖 $ bundle exec jekyll server # 运行 Jekyll 安装bundler可能会受网络影响，可以把Gems Source换成gems.ruby-china.org： $ bundle config mirror.https://rubygems.org https://gems.ruby-china.org 如果遇到SSL证书问题，你又无法解决，请直接用 http://gems.ruby-china.org （https替换为http）避免。（另一种解决方式） Codinfox-lanyon主题因为Jekyll升级到3.0之前的一些老插件在Jacman上用不了，加之修改源码的学习成本高，遂换了这款主题。其实之前尝试在默认主题下添加目录导航，但发现Github Pages不支持jekyll-archives， 只能修改前端源码，由于缺乏必要的前端知识，还是放弃折腾了。安装过程很简单，直接clone下来，修改下配置文件，替换原始文件（除了 .git ）即可。 Hexo框架环境搭建 Hexo基于Node.js，所以先安装Node.js。然后安装Git。 安装Hexo$ npm install -g hexo-cli 安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。$ hexo init &lt;folder&gt; $ cd &lt;folder&gt; $ npm install $ hexo g # 或者hexo generate $ hexo s # 或者hexo server，可以在http://localhost:4000/ 查看 npm的安装有时候会因为网络问题卡住，这时候多试几次，目前没啥好办法。 主题安装下载主题包放在 themes 文件夹内，然后修改 _config.yml 内的 theme 设定，即可切换主题。本人使用的是next主题。 常用的Hexo命令$ hexo generate (hexo g) # 生成静态文件，会在当前目录下生成一个新的叫做public的文件夹 $ hexo server (hexo s) # 启动本地web服务，用于博客的预览 $ hexo deploy (hexo d) # 部署播客到远端（比如github, heroku等平台） $ hexo new &quot;postName&quot; # 新建文章 $ hexo new page &quot;pageName&quot; # 新建页面 部署到Github Pages 安装扩展$ npm install hexo-deployer-git --save 需要先配置好ssh秘钥。 修改 _config.ymldeploy: type: git repo: git@github.com:jiji262/jiji262.github.io.git branch: master 然后执行$ hexo d 即上传到了Github。当然如果你喜欢使用git命令的话可以直接在 $ hexo g 生成的 public 文件夹下添加 .git 文件夹，结合ATOM直接 $ git push ，这样可以添加自定义的commit修改记录。 Jekyll的迁移把 _posts 文件夹内的所有文件复制到 source/_posts 文件夹，并在 _config.yml 中修改 new_post_name 参数。 new_post_name: :year-:month-:day-:title.md 表格CSS优化表格宽度自动：blog\themes\next\source\css\_common\scaffolding\tables.styl修改table-layout: automatic;表格样式修改：在blog\themes\next\source\css\_custom\custom.styl增加以下内容：123456789101112131415161718192021222324252627282930table &#123; width: 100%; /*表格宽度*/ max-width: 65em; /*表格最大宽度，避免表格过宽*/ border: 1px solid #dedede; /*表格外边框设置*/ margin: 15px auto; /*外边距*/ border-collapse: collapse; /*使用单一线条的边框*/ empty-cells: show; /*单元格无内容依旧绘制边框*/ border-radius: 4px; table-layout: automatic;&#125;table th,table td &#123; height: 35px; /*统一每一行的默认高度*/ border: 1px solid #dedede; /*内部边框样式*/ padding: 0 10px; /*内边距*/&#125;table th &#123; font-weight: bold; /*加粗*/ text-align: center !important; /*内容居中，加上 !important 避免被 Markdown 样式覆盖*/ background: rgba(158,188,226,0.2); /*背景色*/&#125;table th &#123; white-space: nowrap; /*表头内容强制在一行显示*/&#125;table td:nth-child(1) &#123; /*首列不换行*/ white-space: nowrap;&#125;table tr:hover &#123; background: #efefef;&#125; 关联Github 安装GitGit for Windows 配置Git参考Git语法备忘录 撰写博客 Jekyll和Hexo都识别markdown语法，MD编辑器我使用的是sublime，简洁好用 使用ATOM作为MD的编辑器，control + shift + M 自动调出预览效果。博文放在目录_post下面，按照日期-标题的命名规则新建markdown后缀的文件，打开文件后输入必要的YML信息，具体可以参考自带的示例。编辑好文章后就可以使用Git push上去了。Jekyll会自动转化相应的静态网页。 Push的时候可以使用ATOM的Git Plus插件（需要先配置Git Bash），安装好之后不需要在Git Plus中修改参数，path直接用默认的git即可（可以在cmd中使用git确认是否在环境中配置成功）。在ATOM-FILE-ADD PROJECT FOLDER加入Repository，因为文件夹包含git子文件夹，atom会自动识别，随后使用control + shift + A添加文件，control + shift + X添加评论，最后鼠标点个Push即可。如果没有成功的确认下Git Bash有没有配置成功。 Other微信链接的图片尺寸必须大于： 300px × 300px，打入如下代码隐藏图片 1234&lt;div style="display: none;" document.getElementById("typediv1").style.display="none";&gt;&lt;img src="/img/git.jpg" &gt;&lt;/div&gt; 参考资料： 手把手教你使用Hexo + Github Pages搭建个人独立博客 NexT主题配置]]></content>
      <tags>
        <tag>jekyll</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>